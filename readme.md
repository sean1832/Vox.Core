# Vox.Core

Vox.Core is a C# library that provides a collection of voxelization algorithms for 3D meshes. It focuses on performance and ease of use while offering flexibility through different voxelization techniques. It is not as performant as native C++ libraries, however, it is suitable for prototyping, research, and educational purposes.

> **Note:** This library is under active development and not yet ready for production use.

## Features
#### Voxelization Algorithms
- **Sparse Voxel Octree (SVO)**
  - **Bounding Volume Hierarchy (BVH) Optimizations**
- **Spatial Hashing**
- **Morton Encoding**

#### Meshing Algorithms
- **Naive**
- **Face-Culling**
- **Marching Cubes** (Coming Soon)
- **Greedy Meshing** (Coming Soon)

## Voxel Algorithms

### Morton Encoding
Morton encoding is a technique that interleaves the bits of the 3D coordinates 
of a voxel to create a single index. This method is useful for spatially 
sorting voxels in a way that preserves locality, making it easier to access 
neighboring voxels efficiently. This algorithm is also suitable for voxelizing dynamic models
and is even faster than spatial hashing for such cases.

#### Basic Usage
```csharp
PMesh mesh; // Input mesh
PVector3d cellSize = new PVector3d(1.5, 0.5, 0.5); // Size of the grid cell
List<Voxel> voxels = Voxelizer.VoxelizeMorton(mesh, cellSize);
```

### Spatial Hashing
Spatial hashing is a voxelization algorithm that divides space into a grid of cells.
Each cell contains information about the voxels that intersect it, 
making it a memory-efficient method for voxelization. 
This algorithm is suitable for voxelizing complex dynamic models with a uniform 
grid structure and is faster than SVO for such cases.

#### Basic Usage
```csharp
PMesh mesh; // Input mesh
PVector3d cellSize = new PVector3d(1.5, 0.5, 0.5); // Size of the grid cell
List<Voxel> voxels = Voxelizer.VoxelizeSH(mesh, cellSize);
```


### Sparse Voxel Octree (SVO)

The [Sparse Voxel Octree](https://eisenwave.github.io/voxel-compression-docs/svo/svo.html) (SVO) is a hierarchical voxelization algorithm that represents a 3D model as an octree. At each level, the model is recursively subdivided into eight smaller regions, making the algorithm space-efficient. SVO only stores information about voxels at the surface of the model, reducing memory usage compared to a full grid-based representation.

#### Basic Usage (Without Optimization)
This example demonstrates how to voxelize a mesh using SVO without additional optimizations.

```csharp
int depth = 4; // Specifies the depth of the octree (more depth = finer detail)
bool isSolid = false; // Whether voxels should be treated as solid
List<Voxel> voxels = Voxelizer.VoxelizeSVO(mesh, depth, isSolid);

// Voxel has the following properties:
// - Position: The 3D position of the voxel (x, y, z)
// - Size: The size of the voxel (x, y, z)
// - State: Inside, Outside, or Intersection with the model's surface
```

#### BVH Optimization
The [Bounding Volume Hierarchy](https://en.wikipedia.org/wiki/Bounding_volume_hierarchy) (BVH) is a data structure that improves voxelization performance by spatially organizing the mesh's triangles. This reduces the number of triangles processed during voxelization, speeding up computation without sacrificing accuracy.

##### Example of BVH Optimized Voxelization:

1. **BVH Setup:** First, construct a BVH from the mesh. This is a one-time operation.
2. **Voxelization Process:** Use the BVH to guide the SVO voxelization.

```csharp
// Step 1: Create a BVH for the mesh (One-time setup)
int maxTrianglesPerLeaf = 16; // Max number of triangles per leaf node
int bucketSize = 4; // Bucket size for SAH heuristic
mesh.ComputeTriangleBounds(); // Precompute triangle bounds
BVH bvh = new BVH(mesh, maxTrianglesPerLeaf, bucketSize); // Create BVH

// Step 2: Voxelize using the BVH structure
int depth = 4; // Octree depth for voxelization
bool isSolid = false; // Whether the voxels should be treated as solid
List<Voxel> voxels = Voxelizer.VoxelizeSVO(bvh, depth, isSolid);
```


## Meshing Algorithms

### Naive
Naive meshing is a simple algorithm that generates a mesh from voxels by creating a cube for each voxel.
This method is straightforward but can lead to inefficient meshes with many redundant vertices and faces.

```csharp
var positions = new List<PVector3d>(); // List of voxel positions
var sizes = new List<PVector3d>(); // List of voxel sizes

// Right-handed or left-handed coordinate system
// OpenGL uses a right-handed system, while Rhino3D uses a left-handed system
CordSystem cordSys = CordSystem.LeftHanded; 

// Extract voxel positions and sizes
foreach (var voxel in voxels)
{
  positions.Add(voxel.Position);
  sizes.Add(voxel.Size);
}

List<PMesh> meshes = Mesher.Generate(MeshingAlgorithm.Naive, positions, sizes, cordSys);
```

### Face-Culling
Face-culling meshing is an optimization that reduces the number of faces generated by the naive algorithm. It removes faces that are not visible from the outside of the mesh, improving mesh efficiency.

```csharp
List<PMesh> meshes = Mesher.Generate(MeshingAlgorithm.FaceCulling, positions, sizes, cordSys);
```